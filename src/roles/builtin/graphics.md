# 图形编程规范 - CODING-STANDARDS-GRAPHICS

**版本**: 2.0.0
**适用范围**: 图形编程岗位（2D/3D渲染/GPU编程/着色器，API无关）
**最后更新**: 2025-12-25

---

## 🚨 核心铁律（继承自 common.md）

> **必须遵循 common.md 的四大核心铁律**

```
铁律1: SPEC 是唯一真源（SSOT）
       - 渲染管线必须符合 SPEC 定义
       - 光照、材质、后处理以 SPEC 为准

铁律2: 智能复用与销毁重建
       - 现有着色器完全匹配 → 直接复用
       - 部分匹配 → 删除重写

铁律3: 禁止渐进式开发
       - 禁止在旧着色器上添加新功能
       - 禁止保留兼容性代码路径

铁律4: Context7 调研先行
       - 使用成熟的渲染框架
       - 禁止自己实现 PBR/GI 等复杂算法
```

---

## 🎨 渲染管线

### 管线组织
- ✅ 分离渲染阶段（几何/光照/后处理）
- ✅ 状态排序（减少状态切换）
- ✅ 批次排序（材质/纹理/着色器）
- ✅ 透明物体后渲染
- ❌ 避免频繁切换渲染状态

### 坐标系统
- ✅ 明确坐标系（左手/右手）
- ✅ 变换矩阵顺序清晰
- ✅ 投影矩阵参数合理
- ✅ 视锥体设置正确
- ❌ 避免矩阵乘法顺序错误

### 深度和剔除
- ✅ 启用深度测试
- ✅ 背面剔除（Backface Culling）
- ✅ 视锥体剔除（Frustum Culling）
- ✅ 遮挡剔除（Occlusion Culling）
- ✅ 早期深度测试（Early-Z）
- ❌ 避免过度绘制（Overdraw）

---

## 🖌️ 着色器开发

### 着色器设计
- ✅ 顶点着色器：变换和光照计算
- ✅ 片段着色器：纹理采样和颜色计算
- ✅ 计算着色器：通用GPU计算
- ✅ 几何着色器：动态几何生成（谨慎使用）
- ❌ 避免在片段着色器做复杂计算

### 着色器优化
- ✅ 减少分支（if语句）
- ✅ 向量化操作（vec4, mat4）
- ✅ 预计算常量
- ✅ 纹理采样优化（Mipmaps）
- ✅ 精度声明（lowp/mediump/highp）
- ❌ 避免循环（或限制迭代次数）

### 着色器编译
- ✅ 编译时检查错误
- ✅ 着色器变体管理
- ✅ Uber Shader vs 专用着色器
- ✅ 着色器预编译
- ❌ 避免运行时编译错误

---

## 🗂️ 资源管理

### 缓冲区管理
- ✅ 顶点缓冲区（VBO）
- ✅ 索引缓冲区（IBO）
- ✅ 统一缓冲区（UBO）
- ✅ 实例化缓冲区
- ✅ 缓冲区重用（对象池）
- ❌ 避免频繁创建销毁

### 纹理管理
- ✅ 纹理压缩（DXT/ETC/ASTC）
- ✅ Mipmaps生成
- ✅ 纹理过滤（双线性/三线性/各向异性）
- ✅ 纹理图集（Atlas）
- ✅ 流式加载大纹理
- ❌ 避免未压缩纹理

### 内存管理
- ✅ 监控显存使用
- ✅ 及时释放未使用资源
- ✅ LOD（细节层次）
- ✅ 资源异步加载
- ❌ 避免显存泄漏

---

## ⚡ 性能优化

### 批处理
- ✅ 实例化渲染（Instancing）
- ✅ 批次合并（Batching）
- ✅ 减少Draw Call
- ✅ 间接绘制（Indirect Drawing）
- ❌ 避免每帧重建缓冲区

### GPU优化
- ✅ 异步计算
- ✅ GPU Profiling
- ✅ 像素填充率优化
- ✅ 带宽优化
- ✅ 寄存器压力管理
- ❌ 避免GPU停滞（Stall）

### CPU-GPU同步
- ✅ 双缓冲/三缓冲
- ✅ 异步资源上传
- ✅ 减少CPU-GPU同步点
- ✅ 命令缓冲预记录
- ❌ 避免管线阻塞

---

## 💡 光照和材质

### 光照模型
- ✅ PBR（物理渲染）
- ✅ 延迟渲染 vs 前向渲染
- ✅ 阴影映射（Shadow Mapping）
- ✅ 环境光遮蔽（AO）
- ✅ 全局光照（GI）近似
- ❌ 避免过多光源（性能）

### 材质系统
- ✅ 材质属性参数化
- ✅ 材质实例化
- ✅ 材质LOD
- ✅ 材质合批
- ❌ 避免重复材质

### 阴影优化
- ✅ 级联阴影图（CSM）
- ✅ 阴影分辨率合理
- ✅ 软阴影（PCF）
- ✅ 阴影距离限制
- ❌ 避免全场景阴影

---

## 🎞️ 后处理

### 后处理流程
- ✅ HDR渲染
- ✅ 色调映射（Tone Mapping）
- ✅ 伽马校正
- ✅ 抗锯齿（FXAA/TAA/MSAA）
- ✅ 泛光（Bloom）
- ❌ 避免过度后处理（性能）

### 帧缓冲
- ✅ 离屏渲染
- ✅ 多渲染目标（MRT）
- ✅ 帧缓冲复用
- ✅ 深度/模板缓冲
- ❌ 避免不必要的帧缓冲

---

## 🖥️ 多平台兼容

### API抽象
- ✅ 抽象渲染接口
- ✅ 平台特定优化
- ✅ 着色器跨平台编译
- ✅ 资源格式兼容
- ❌ 避免硬编码API调用

### 性能分级
- ✅ 根据硬件调整画质
- ✅ 自动检测GPU能力
- ✅ 可配置渲染选项
- ✅ 移动端特殊优化
- ❌ 避免一刀切的配置

---

## 🧪 调试和分析

### 调试工具
- ✅ 图形调试器（RenderDoc/NSight）
- ✅ 线框模式（Wireframe）
- ✅ 法线/UV可视化
- ✅ 深度/阴影缓冲可视化
- ✅ 热重载着色器
- ❌ 不要依赖printf调试

### 性能分析
- ✅ GPU Profiler
- ✅ Draw Call统计
- ✅ 帧时间分析
- ✅ 内存占用监控
- ✅ 瓶颈识别（CPU/GPU）
- ❌ 避免过早优化

---

## 📋 图形编程检查清单

- [ ] 渲染状态排序和批次优化
- [ ] 深度测试和背面剔除
- [ ] 着色器优化（减少分支和循环）
- [ ] 纹理压缩和Mipmaps
- [ ] 实例化和批处理（减少Draw Call）
- [ ] 光照和阴影优化
- [ ] 后处理合理配置
- [ ] 资源管理（显存监控）
- [ ] 多平台兼容性
- [ ] 性能分析和调试

---

---

## 🏛️ 高级图形架构（20+年经验）

### 现代渲染管线
```
延迟渲染（Deferred）：
- G-Buffer 结构设计
- 延迟光照
- 解耦光照和几何
- 适用：大量光源

前向+（Forward+）：
- 光源分簇（Clustered）
- 光源剔除
- 透明物体支持
- 适用：移动端友好

混合渲染：
- 延迟 + 前向透明
- 可见性缓冲（Visibility Buffer）
- 虚拟纹理

光线追踪：
- DXR/Vulkan RT
- BVH 加速结构
- 混合渲染（光追 + 光栅化）
- 降噪算法（Denoiser）
```

### GPU 驱动渲染
```
间接绘制：
- Indirect Draw
- Multi-Draw Indirect
- GPU 剔除

可编程渲染管线：
- Mesh Shader
- Task Shader
- Meshlet 几何

GPU 计算：
- 计算着色器通用计算
- 粒子系统 GPU 模拟
- 物理模拟
- 遮挡剔除 GPU 版
```

### 大世界渲染
```
LOD 系统：
- 离散 LOD
- 连续 LOD（CLOD）
- 几何 LOD + 纹理 LOD

流式加载：
- 地形流式
- 虚拟纹理
- 内存管理
- 后台加载

空间数据结构：
- 四叉树/八叉树
- BVH
- 空间哈希
- 分层剔除
```

---

## 🔧 资深图形专家必备技巧

### Shader 优化深度
```
ALU 优化：
- MAD（乘加融合）
- 向量运算
- 减少标量操作
- 常量折叠

内存访问优化：
- 纹理缓存局部性
- 合并内存访问
- 减少 bandwidth
- Tile-Based 架构优化（移动端）

分支优化：
- 避免发散分支
- 使用 step/lerp 替代 if
- 预计算 LUT
- Ubershader 变体管理
```

### 性能分析深度
```
GPU Profiler：
- RenderDoc
- NVIDIA NSight
- PIX for Windows
- Xcode GPU Tools

分析方法：
- 找瓶颈：顶点/像素/带宽
- 帧分解分析
- 热点识别
- A/B 对比测试

常见瓶颈：
- 过度绘制
- 状态切换
- 纹理带宽
- 顶点处理
```

### 现代 API 技巧
```
Vulkan/DX12 优势：
- 多线程命令录制
- 显式资源管理
- 管线状态对象
- 描述符集/表

同步和屏障：
- 资源转换屏障
- 队列家族
- 信号量
- 栅栏

内存管理：
- 内存类型选择
- 子分配
- 内存别名
- 资源堆
```

### 光照高级技术
```
全局光照：
- 光线追踪 GI
- 体素 GI（VXGI）
- 屏幕空间 GI（SSGI）
- 辐照度探针

阴影技术：
- 级联阴影图（CSM）
- 可变半影软阴影（PCSS）
- 阴影体
- 光线追踪阴影

反射：
- 屏幕空间反射（SSR）
- 光线追踪反射
- 反射探针
- 平面反射
```

---

## 🚨 资深图形专家常见陷阱

### 架构陷阱
```
❌ 过早优化：
- 没有分析就优化
- 优化非瓶颈
- 正确做法：Profile 先行

❌ 不考虑最差情况：
- 只测试简单场景
- 忽视极端情况
- 正确做法：压力测试

❌ API 抽象过厚：
- 过度封装
- 性能损失
- 正确做法：薄抽象，直接访问
```

### 性能陷阱
```
❌ 过多 Draw Call：
- 没有批处理
- 频繁状态切换
- 正确做法：实例化、合批

❌ 过度后处理：
- 所有特效都开
- 全分辨率处理
- 正确做法：降采样、按需开启

❌ 忽视移动端：
- PC 优化直接用于移动
- 忽视 Tile-Based
- 正确做法：平台特定优化
```

### 兼容性陷阱
```
❌ 硬编码扩展：
- 假设扩展存在
- 无回退路径
- 正确做法：能力检测

❌ 忽视驱动差异：
- 只在一家GPU测试
- 忽视驱动 bug
- 正确做法：多厂商测试

❌ 浮点精度问题：
- 大坐标精度丢失
- 世界空间计算
- 正确做法：相机相对渲染
```

---

## 📊 性能监控指标

| 指标 | 目标值 | 告警阈值 | 测量工具 |
|------|--------|----------|----------|
| 帧率 | 60 FPS | < 30 FPS | GPU Profiler |
| 帧时间 | < 16.7ms | > 33ms | GPU Profiler |
| Draw Call | < 2000 | > 5000 | 引擎统计 |
| 三角形数 | 根据场景 | > 预算 | 引擎统计 |
| 过度绘制 | < 2x | > 4x | GPU Profiler |
| 显存使用 | < 80% | > 95% | GPU 监控 |
| 纹理内存 | 根据预算 | > 预算 | 引擎统计 |
| 顶点处理时间 | < 5ms | > 10ms | GPU Profiler |
| 像素处理时间 | < 10ms | > 16ms | GPU Profiler |
| 状态切换 | < 1000 | > 3000 | 引擎统计 |

---

## 📋 图形编程检查清单（完整版）

### 渲染管线
- [ ] 渲染架构选择合理
- [ ] 状态排序优化
- [ ] 剔除策略完整
- [ ] LOD 系统工作正常

### 性能优化
- [ ] Draw Call 在预算内
- [ ] 批处理/实例化
- [ ] 纹理压缩
- [ ] Shader 优化

### 视觉质量
- [ ] 光照模型正确
- [ ] 阴影质量达标
- [ ] 后处理配置合理
- [ ] 抗锯齿有效

### 跨平台
- [ ] 多 GPU 厂商测试
- [ ] 移动端优化
- [ ] 能力检测和回退

---

**图形编程原则总结**：
管线优化、状态排序、批处理、着色器优化、纹理管理、光照阴影、后处理、资源管理、多平台、性能分析
