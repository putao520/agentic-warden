# 嵌入式开发规范 - CODING-STANDARDS-EMBEDDED

**版本**: 2.0.0
**适用范围**: 嵌入式开发岗位（MCU/SoC/RTOS/裸机，平台无关）
**最后更新**: 2025-12-25

---

## 🚨 核心铁律（继承自 common.md）

> **必须遵循 common.md 的四大核心铁律**

```
铁律1: SPEC 是唯一真源（SSOT）
       - 硬件接口必须符合 SPEC 定义
       - 时序、协议、资源约束以 SPEC 为准

铁律2: 智能复用与销毁重建
       - 现有驱动完全匹配 → 直接复用
       - 部分匹配 → 删除重写

铁律3: 禁止渐进式开发
       - 禁止在旧驱动上添加新功能
       - 禁止保留兼容性代码

铁律4: Context7 调研先行
       - 使用官方 HAL/SDK
       - 禁止自己实现通信协议栈
```

---

## 💾 资源管理

### 内存管理
- ✅ 静态分配优先（栈/全局）
- ✅ 避免动态分配（malloc/free）
- ✅ 栈大小合理配置
- ✅ 内存对齐
- ✅ 监控内存使用（栈/堆）
- ❌ 禁止无限递归（栈溢出）

### 代码优化
- ✅ 代码大小优化（-Os）
- ✅ 使用常量和宏（节省RAM）
- ✅ 只链接需要的库
- ✅ 移除未使用代码
- ✅ 内联关键函数
- ❌ 避免过度优化（可读性）

### 数据存储
- ✅ 区分RAM/ROM/Flash存储
- ✅ 常量放ROM（const/PROGMEM）
- ✅ Flash写入次数限制
- ✅ EEPROM磨损均衡
- ❌ 避免频繁写Flash

---

## ⚡ 实时性

### 中断处理
- ✅ 中断服务程序尽可能短
- ✅ 延迟处理（底半部机制）
- ✅ 禁止在ISR中阻塞
- ✅ 禁止在ISR中分配内存
- ✅ 中断优先级合理配置
- ❌ 避免中断嵌套过深

### 任务调度
- ✅ 实时任务优先级高
- ✅ 任务周期明确
- ✅ 最坏情况执行时间（WCET）分析
- ✅ 避免优先级反转
- ✅ 使用抢占式调度（RTOS）
- ❌ 避免任务饥饿

### 时序保证
- ✅ 硬实时任务截止时间保证
- ✅ 软实时任务尽力保证
- ✅ 看门狗定时器
- ✅ 超时检测
- ❌ 避免不确定延迟

---

## 🔌 硬件交互

### 寄存器操作
- ✅ 使用硬件抽象层（HAL）
- ✅ 位操作清晰（BIT_SET/BIT_CLEAR）
- ✅ 寄存器访问volatile修饰
- ✅ 读-改-写原子性
- ❌ 避免直接硬编码地址

### GPIO和外设
- ✅ GPIO初始化配置
- ✅ 中断引脚去抖动
- ✅ 外设时钟使能
- ✅ DMA提高效率
- ✅ 外设复用冲突检测
- ❌ 避免浮空引脚

### 通信协议
- ✅ UART/SPI/I2C配置正确
- ✅ 超时和错误处理
- ✅ 缓冲区溢出检查
- ✅ CRC/校验和验证
- ❌ 避免轮询等待（使用中断/DMA）

---

## 🔋 功耗优化

### 低功耗模式
- ✅ 空闲时进入睡眠模式
- ✅ 深度睡眠唤醒机制
- ✅ 外设时钟门控
- ✅ 降低时钟频率
- ❌ 避免忙等待（Busy-Wait）

### 功耗监控
- ✅ 测量功耗
- ✅ 优化唤醒频率
- ✅ 批量处理任务
- ✅ 传感器按需采样
- ❌ 避免不必要的唤醒

---

## 🛡️ 安全和可靠性

### 错误处理
- ✅ 断言（Assert）检查
- ✅ 错误码返回
- ✅ 看门狗复位
- ✅ 硬件故障检测
- ✅ 掉电保护
- ❌ 不要忽略错误

### 数据完整性
- ✅ CRC/校验和验证
- ✅ 重要数据冗余存储
- ✅ 数据备份和恢复
- ✅ Flash分区保护
- ❌ 避免数据损坏

### 安全启动
- ✅ Bootloader验证固件
- ✅ 签名验证
- ✅ 回滚保护
- ✅ 安全密钥存储
- ❌ 禁止调试接口暴露（生产）

---

## 🔄 并发控制

### 临界区保护
- ✅ 禁中断保护临界区
- ✅ 互斥锁（Mutex）
- ✅ 信号量（Semaphore）
- ✅ 临界区尽可能短
- ❌ 避免死锁

### 数据共享
- ✅ volatile修饰共享变量
- ✅ 原子操作
- ✅ 无锁数据结构（Ring Buffer）
- ✅ 消息队列
- ❌ 避免竞态条件

---

## 🚀 固件更新

### OTA更新
- ✅ 双分区（A/B分区）
- ✅ 更新前验证
- ✅ 更新失败回滚
- ✅ 断电保护
- ✅ 增量更新（减少数据量）
- ❌ 避免砖机风险

### 版本管理
- ✅ 固件版本号
- ✅ 兼容性检查
- ✅ 降级保护
- ✅ 版本日志
- ❌ 避免版本混乱

---

## 🧪 测试和调试

### 单元测试
- ✅ 业务逻辑单元测试
- ✅ 模拟硬件（Mock）
- ✅ 边界条件测试
- ✅ 压力测试
- ❌ 不要跳过测试

### 硬件测试
- ✅ 在目标硬件测试
- ✅ 长时间稳定性测试
- ✅ 温度/电压变化测试
- ✅ EMC测试
- ❌ 避免只在理想环境测试

### 调试工具
- ✅ JTAG/SWD调试
- ✅ 日志输出（UART/ITM）
- ✅ 断言和错误码
- ✅ 内存转储
- ❌ 避免printf调试（资源消耗大）

---

## 📋 嵌入式开发检查清单

- [ ] 内存使用优化（静态分配优先）
- [ ] 中断服务程序简短高效
- [ ] 实时任务调度合理
- [ ] 硬件寄存器访问安全
- [ ] 功耗优化（睡眠/时钟门控）
- [ ] 错误处理和看门狗
- [ ] 临界区保护（防竞态）
- [ ] 固件更新安全（验证/回滚）
- [ ] 目标硬件充分测试
- [ ] 代码大小和性能优化

---

---

## 🏛️ 高级嵌入式架构（20+年经验）

### RTOS 高级架构
```
任务设计模式：
- 生产者-消费者：传感器采集 → 数据处理
- 状态机模式：复杂控制逻辑
- 事件驱动：中断 → 事件 → 处理
- 优先级继承：解决优先级反转

内存架构：
- 静态分配（编译时确定）
- 内存池（固定大小块）
- 无碎片设计
- 栈保护（MPU）

时序分析：
- WCET（最坏情况执行时间）
- 响应时间分析
- 调度可行性验证
- 时间分区（ARINC 653）
```

### 安全关键系统
```
功能安全标准：
- ISO 26262（汽车）
- IEC 61508（通用）
- DO-178C（航空）
- IEC 62443（工业）

ASIL/SIL 等级设计：
- 冗余设计（双核/三模）
- 故障检测和响应
- 看门狗层次
- 安全监控器

验证和测试：
- 单元测试覆盖 100%
- MC/DC 覆盖率
- 静态分析（MISRA）
- 形式化验证
```

### 硬件抽象层设计
```
HAL 架构：
- 驱动分层：硬件 → HAL → 中间件 → 应用
- 平台抽象：便于移植
- BSP 分离：板级支持包
- 设备树/配置文件

驱动设计：
- 阻塞 vs 非阻塞
- 轮询 vs 中断 vs DMA
- 缓冲管理
- 电源状态管理
```

---

## 🔧 资深嵌入式专家必备技巧

### 调试深度技巧
```
硬件调试：
- JTAG/SWD 断点和追踪
- ITM/ETM 跟踪（Trace）
- 逻辑分析仪
- 示波器协议解码

内存调试：
- 内存转储分析
- 栈回溯（Backtrace）
- 内存保护单元（MPU）
- 堆栈使用分析

时序调试：
- 引脚翻转测量
- 示波器时序分析
- 实时跟踪（SystemView）
- 延迟抖动分析
```

### 功耗优化深度
```
测量方法：
- 电流探头测量
- 功率分析仪
- 不同模式功耗表征
- 电池寿命建模

优化策略：
- 动态电压频率调节（DVFS）
- 外设时钟门控
- 睡眠模式选择
- 唤醒源优化

超低功耗设计：
- 亚阈值电路
- 能量收集
- 事件驱动唤醒
- 功耗预算管理
```

### 实时性能调优
```
中断优化：
- 中断延迟测量
- 中断优先级规划
- 中断尾链（Tail Chaining）
- 向量中断控制器

任务优化：
- 上下文切换开销
- 任务切片（Time Slicing）
- 就绪队列优化
- 调度器 Tick 优化

DMA 高级用法：
- 双缓冲/乒乓缓冲
- 链式 DMA
- 循环模式
- 传输完成回调
```

### 安全启动和固件保护
```
安全启动链：
- ROM Bootloader → 一级引导 → 二级引导 → 应用
- 签名验证（RSA/ECDSA）
- 哈希链验证
- 回滚保护

固件保护：
- 代码加密
- 读保护（RDP）
- 调试端口禁用
- 防篡改检测

密钥管理：
- 安全存储（OTP/Fuse）
- 密钥派生
- 密钥更新机制
- 硬件安全模块（HSM）
```

---

## 🚨 资深嵌入式专家常见陷阱

### 架构陷阱
```
❌ 忽视 WCET 分析：
- 假设任务总能完成
- 实际出现截止时间违反
- 正确做法：分析和测试最坏情况

❌ 过度使用动态分配：
- 堆碎片化
- 分配失败
- 正确做法：静态分配 + 内存池

❌ 中断处理过长：
- 影响实时性
- 优先级反转
- 正确做法：快速返回，延迟处理
```

### 调试陷阱
```
❌ 依赖 printf 调试：
- 改变时序
- 资源消耗大
- 正确做法：使用 ITM/RTT

❌ 忽视优化级别影响：
- 调试版和发布版行为不同
- 变量被优化消除
- 正确做法：在目标配置下测试

❌ 不测试极端条件：
- 只在室温测试
- 忽视电压波动
- 正确做法：环境极限测试
```

### 安全陷阱
```
❌ 明文存储密钥：
- 固件逆向泄露
- 正确做法：安全存储 + 加密

❌ 忽视调试接口：
- 生产设备可调试
- 正确做法：禁用或保护调试端口

❌ 固件更新无验证：
- 接受恶意固件
- 正确做法：签名验证 + 回滚保护
```

---

## 📊 性能监控指标

| 指标 | 目标值 | 告警阈值 | 测量方法 |
|------|--------|----------|----------|
| 中断延迟 | < 10μs | > 50μs | 示波器/ITM |
| 任务响应时间 | < WCET | > 90% WCET | 追踪工具 |
| 栈使用率 | < 70% | > 90% | 栈水印 |
| CPU 利用率 | < 70% | > 90% | RTOS 统计 |
| 功耗（活动） | 根据设计 | > 预算 | 电流探头 |
| 功耗（睡眠） | < 10μA | > 100μA | 电流探头 |
| 启动时间 | < 1s | > 5s | 示波器 |
| 看门狗触发 | 0 | > 0 | 日志 |
| 硬故障次数 | 0 | > 0 | 错误日志 |
| Flash 写入次数 | < 10% 寿命 | > 50% 寿命 | 磨损计数 |

---

## 📋 嵌入式开发检查清单（完整版）

### 资源管理
- [ ] 静态内存分配
- [ ] 栈大小合理配置
- [ ] 无内存泄漏
- [ ] Flash/RAM 使用监控

### 实时性
- [ ] WCET 分析完成
- [ ] 中断响应时间达标
- [ ] 无优先级反转
- [ ] 看门狗正常

### 安全性
- [ ] 安全启动链完整
- [ ] 固件签名验证
- [ ] 调试端口禁用
- [ ] 密钥安全存储

### 功耗
- [ ] 睡眠模式正确
- [ ] 功耗预算达标
- [ ] 唤醒机制可靠

---

**嵌入式开发原则总结**：
资源约束、实时性、硬件交互、功耗优化、安全可靠、并发控制、固件更新、测试充分、调试工具、代码优化
