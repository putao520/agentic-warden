# 游戏开发规范 - CODING-STANDARDS-GAME

**版本**: 2.0.0
**适用范围**: 游戏开发岗位（2D/3D/移动/PC/主机游戏，引擎无关）
**最后更新**: 2025-12-25

---

## 🚨 核心铁律（继承自 common.md）

> **必须遵循 common.md 的四大核心铁律**

```
铁律1: SPEC 是唯一真源（SSOT）
       - 游戏机制必须符合 SPEC 定义
       - 数值、规则、交互以 SPEC 为准

铁律2: 智能复用与销毁重建
       - 现有系统完全匹配 → 直接复用
       - 部分匹配 → 删除重建

铁律3: 禁止渐进式开发
       - 禁止在旧系统上添加新功能
       - 禁止保留兼容性代码

铁律4: Context7 调研先行
       - 使用成熟的游戏框架和插件
       - 禁止自己实现物理/渲染引擎
```

---

## 🎮 游戏循环和时序

### 主循环设计
- ✅ 固定时间步长更新游戏逻辑
- ✅ 可变时间步长渲染
- ✅ Delta Time传递到所有需要的系统
- ✅ 帧率独立的游戏逻辑
- ❌ 避免将游戏逻辑绑定到帧率

### 时间管理
- ✅ 使用游戏时间而非真实时间
- ✅ 支持时间缩放（慢动作/加速）
- ✅ 暂停时停止游戏逻辑更新
- ✅ 倒计时和定时器使用统一时间系统
- ❌ 避免硬编码延迟值

### 性能目标
- ✅ 目标帧率明确（60fps/30fps）
- ✅ 预算每帧时间（16.6ms@60fps）
- ✅ 监控帧时间波动
- ✅ 掉帧时优雅降级
- ❌ 避免单帧超时（卡顿）

---

## 🏗️ 架构模式

### 组件化设计
- ✅ 实体-组件-系统（ECS）或组件模式
- ✅ 组件单一职责
- ✅ 组件间松耦合
- ✅ 通过消息/事件通信
- ❌ 避免组件间直接引用

### 状态管理
- ✅ 使用状态机管理游戏状态
- ✅ 明确状态转换条件
- ✅ 层级状态机（状态嵌套）
- ✅ 状态进入/退出逻辑清晰
- ❌ 避免复杂的条件判断

### 场景管理
- ✅ 场景加载/卸载异步执行
- ✅ 场景切换显示加载界面
- ✅ 资源预加载
- ✅ 内存管理（卸载未使用资源）
- ❌ 避免场景切换时卡顿

---

## 🎨 资源管理

### 资源加载
- ✅ 异步加载资源
- ✅ 资源池化（对象池、音效池）
- ✅ 懒加载非关键资源
- ✅ 分级加载（LOD）
- ✅ 资源引用计数
- ❌ 避免同步阻塞加载

### 资源优化
- ✅ 纹理压缩和Mipmap
- ✅ 音频压缩
- ✅ 模型优化（面数、骨骼数）
- ✅ 打包和压缩资源
- ✅ 移动端资源分辨率适配
- ❌ 避免未压缩的原始资源

### 内存管理
- ✅ 及时释放未使用资源
- ✅ 内存池减少分配开销
- ✅ 监控内存使用
- ✅ 内存泄漏检测
- ❌ 避免频繁分配释放

---

## 🕹️ 输入处理

### 输入系统
- ✅ 支持多种输入设备（键盘/鼠标/手柄/触摸）
- ✅ 输入映射配置化
- ✅ 输入缓冲（防止丢失输入）
- ✅ 组合键和手势识别
- ✅ 输入优先级管理（UI优先于游戏）
- ❌ 避免硬编码输入键位

### 响应性
- ✅ 即时反馈（按键响应<100ms）
- ✅ 输入预测（网络游戏）
- ✅ 防抖和防误触
- ❌ 避免输入延迟

---

## ⚙️ 物理和碰撞

### 物理系统
- ✅ 使用固定时间步长更新物理
- ✅ 物理和渲染分离
- ✅ 碰撞层和碰撞矩阵
- ✅ 触发器和碰撞体分离
- ❌ 避免每帧进行全局碰撞检测

### 碰撞优化
- ✅ 空间分区（四叉树/八叉树/网格）
- ✅ 休眠机制（静止物体不计算）
- ✅ 简化碰撞体（用简单形状）
- ✅ 分层检测（粗检测+精细检测）
- ❌ 避免复杂多边形碰撞

---

## 🎯 游戏逻辑

### 数据驱动
- ✅ 游戏配置数据化（JSON/YAML/表格）
- ✅ 关卡数据与代码分离
- ✅ 敌人/道具/技能数据表
- ✅ 热更新配置数据
- ❌ 避免硬编码游戏数值

### 平衡性
- ✅ 数值公式参数化
- ✅ 平衡性测试和调优
- ✅ 难度曲线配置
- ✅ 随机性可控（种子）
- ❌ 避免魔法数字

### AI系统
- ✅ 行为树或状态机
- ✅ AI决策帧率限制（不必每帧）
- ✅ AI调试可视化
- ✅ 分级AI复杂度
- ❌ 避免过于复杂的AI（影响性能）

---

## 🌐 多人游戏

### 网络同步
- ✅ 客户端预测和服务器验证
- ✅ 插值和外推
- ✅ 延迟补偿
- ✅ 快照同步
- ❌ 避免信任客户端数据

### 作弊防护
- ✅ 服务器权威
- ✅ 关键逻辑服务器验证
- ✅ 速度检测
- ✅ 数据加密
- ❌ 禁止客户端直接修改关键数据

---

## 💾 保存和序列化

### 存档系统
- ✅ 自动保存和手动保存
- ✅ 多存档槽位
- ✅ 存档版本控制
- ✅ 向后兼容旧存档
- ✅ 数据校验（防止损坏）
- ❌ 避免明文存储（防篡改）

### 序列化
- ✅ 使用成熟序列化库
- ✅ 增量序列化（只保存变化）
- ✅ 压缩存档数据
- ✅ 跨平台兼容
- ❌ 避免序列化复杂对象图

---

## 🎵 音频

### 音频管理
- ✅ 音效和音乐分离
- ✅ 音量控制分组（主音量/音效/音乐/语音）
- ✅ 音频优先级（限制同时播放数量）
- ✅ 3D音效定位
- ❌ 避免音频泄漏（及时释放）

### 优化
- ✅ 音频流式播放（长音乐）
- ✅ 压缩音频格式
- ✅ 音效预加载
- ❌ 避免未压缩的WAV文件

---

## 📊 性能优化

### 渲染优化
- ✅ 批处理和实例化
- ✅ 遮挡剔除和视锥剔除
- ✅ LOD（细节层次）
- ✅ 对象池（减少实例化）
- ✅ Draw Call优化
- ❌ 避免过度绘制

### CPU优化
- ✅ 分帧执行耗时操作
- ✅ 多线程（物理/AI/加载）
- ✅ 缓存计算结果
- ✅ 避免查找和遍历
- ❌ 避免GC压力（减少分配）

### Profiling
- ✅ 定期性能分析
- ✅ 识别性能瓶颈
- ✅ 目标平台测试
- ✅ 内存和帧率监控
- ❌ 不要过早优化

---

## 🧪 测试

### 测试范围
- ✅ 单元测试（游戏逻辑）
- ✅ 集成测试（系统交互）
- ✅ 性能测试（帧率/内存）
- ✅ 平衡性测试（数值/难度）
- ✅ 兼容性测试（多平台/设备）

### 调试工具
- ✅ 控制台命令（调试用）
- ✅ 可视化调试（碰撞体/路径）
- ✅ 作弊码（快速测试）
- ✅ 日志和截图
- ❌ 发布版本移除调试代码

---

## 📋 游戏开发检查清单

- [ ] 游戏逻辑帧率独立
- [ ] 资源异步加载和池化
- [ ] 输入系统支持多设备
- [ ] 物理碰撞优化（空间分区）
- [ ] 游戏数据配置化（数据驱动）
- [ ] 网络同步和作弊防护（多人游戏）
- [ ] 存档系统版本兼容
- [ ] 音频管理和优化
- [ ] 渲染和CPU优化（目标帧率）
- [ ] 性能分析和测试

---

**游戏开发原则总结**：
帧率独立、组件化架构、资源池化、数据驱动、性能优化、网络同步、存档兼容、输入响应、物理优化、调试工具
