// OAuth Client - Using Google Official Libraries
// This module provides OAuth authentication using Google's official yup-oauth2 library

use anyhow::{Context, Result};
use chrono::{DateTime, Duration, Utc};
use serde::{Deserialize, Serialize};
use std::env;
use std::fs;
use std::path::PathBuf;
use tracing::{debug, info};

/// OAuth Configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAuthConfig {
    pub client_id: String,
    pub client_secret: String,
    pub refresh_token: Option<String>,
    pub access_token: Option<String>,
    pub token_expiry: Option<DateTime<Utc>>,
    pub scopes: Vec<String>,
}

impl Default for OAuthConfig {
    fn default() -> Self {
        Self {
            client_id: env::var("GOOGLE_CLIENT_ID").unwrap_or_default(),
            client_secret: env::var("GOOGLE_CLIENT_SECRET").unwrap_or_default(),
            refresh_token: env::var("GOOGLE_REFRESH_TOKEN").ok(),
            access_token: env::var("GOOGLE_ACCESS_TOKEN").ok(),
            token_expiry: None,
            scopes: vec![
                "https://www.googleapis.com/auth/drive.file".to_string(),
                "https://www.googleapis.com/auth/drive.metadata.readonly".to_string(),
            ],
        }
    }
}

/// OAuth Client using Google's official library
#[derive(Debug, Clone)]
pub struct OAuthClient {
    config: OAuthConfig,
    auth_file_path: PathBuf,
}

/// OAuth Token Response
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OAuthTokenResponse {
    pub access_token: String,
    pub refresh_token: Option<String>,
    pub expires_in: u64,
    pub token_type: String,
    pub scopes: Vec<String>,
}

impl OAuthClient {
    /// Create new OAuth client
    pub fn new(client_id: String, client_secret: String, refresh_token: Option<String>) -> Self {
        let config = OAuthConfig {
            client_id,
            client_secret,
            refresh_token,
            access_token: None,
            token_expiry: None,
            scopes: vec![
                "https://www.googleapis.com/auth/drive.file".to_string(),
                "https://www.googleapis.com/auth/drive.metadata.readonly".to_string(),
            ],
        };

        Self {
            config,
            auth_file_path: Self::default_auth_file_path(),
        }
    }

    /// Create OAuth client from environment variables
    pub fn from_env() -> Result<Self> {
        let config = OAuthConfig::default();

        if config.client_id.is_empty() {
            return Err(anyhow::anyhow!(
                "GOOGLE_CLIENT_ID environment variable not set"
            ));
        }

        if config.client_secret.is_empty() {
            return Err(anyhow::anyhow!(
                "GOOGLE_CLIENT_SECRET environment variable not set"
            ));
        }

        Ok(Self {
            config,
            auth_file_path: Self::default_auth_file_path(),
        })
    }

    /// Create OAuth client with custom scopes
    #[allow(dead_code)]
    pub fn with_scopes(mut self, scopes: Vec<String>) -> Self {
        self.config.scopes = scopes;
        self
    }

    /// Create OAuth client with complete token information
    #[allow(dead_code)]
    pub fn with_tokens(
        client_id: String,
        client_secret: String,
        access_token: String,
        refresh_token: String,
        expires_in: u32,
    ) -> Self {
        let config = OAuthConfig {
            client_id,
            client_secret,
            refresh_token: Some(refresh_token),
            access_token: Some(access_token),
            token_expiry: Some(chrono::Utc::now() + chrono::Duration::seconds(expires_in as i64)),
            scopes: vec![
                "https://www.googleapis.com/auth/drive.file".to_string(),
                "https://www.googleapis.com/auth/drive.metadata.readonly".to_string(),
            ],
        };

        Self {
            config,
            auth_file_path: Self::default_auth_file_path(),
        }
    }

    /// Update tokens from OAuth response
    pub fn update_tokens(&mut self, token_response: &OAuthTokenResponse) {
        self.config.access_token = Some(token_response.access_token.clone());
        if let Some(refresh_token) = &token_response.refresh_token {
            self.config.refresh_token = Some(refresh_token.clone());
        }
        self.config.token_expiry =
            Some(chrono::Utc::now() + chrono::Duration::seconds(token_response.expires_in as i64));
    }

    /// Get default auth file path
    fn default_auth_file_path() -> PathBuf {
        let home_dir = dirs::home_dir().unwrap_or_else(|| PathBuf::from("."));
        home_dir.join(".agentic-warden").join("auth.json")
    }

    /// Get auth file path
    pub fn auth_file_path(&self) -> &PathBuf {
        &self.auth_file_path
    }

    /// Save OAuth configuration to file
    pub fn save_config(&self) -> Result<()> {
        if let Some(parent) = self.auth_file_path.parent() {
            fs::create_dir_all(parent).context("Failed to create auth directory")?;
        }

        let content = serde_json::to_string_pretty(&self.config)
            .context("Failed to serialize OAuth config")?;

        fs::write(&self.auth_file_path, content).context("Failed to write auth file")?;

        info!("OAuth configuration saved to: {:?}", self.auth_file_path);
        Ok(())
    }

    /// Load OAuth configuration from file
    pub fn load_config() -> Result<Option<OAuthConfig>> {
        let auth_path = Self::default_auth_file_path();
        Self::load_config_from_path(&auth_path)
    }

    /// Load OAuth configuration from specified path
    pub fn load_config_from_path(auth_path: &PathBuf) -> Result<Option<OAuthConfig>> {
        if !auth_path.exists() {
            return Ok(None);
        }

        let content = fs::read_to_string(auth_path).context("Failed to read auth file")?;

        let config: OAuthConfig =
            serde_json::from_str(&content).context("Failed to parse auth file")?;

        info!("OAuth configuration loaded from: {:?}", auth_path);
        Ok(Some(config))
    }

    /// Get authenticated access token
    pub async fn access_token(&mut self) -> Result<String> {
        // If we have a refresh token, try to use it
        if let Some(_refresh_token) = &self.config.refresh_token {
            match self.refresh_access_token().await {
                Ok(response) => {
                    return Ok(response.access_token);
                }
                Err(e) => {
                    debug!("Token refresh failed: {}, trying code exchange", e);
                }
            }
        }

        // Try to load from stored config
        if let Some(stored_config) = Self::load_config()?
            && let Some(refresh_token) = stored_config.refresh_token {
                self.config.refresh_token = Some(refresh_token);
                match self.refresh_access_token().await {
                    Ok(response) => {
                        return Ok(response.access_token);
                    }
                    Err(e) => {
                        debug!("Stored token refresh failed: {}", e);
                    }
                }
            }
        }

        Err(anyhow::anyhow!("No valid authentication tokens available"))
    }

    /// Refresh access token
    pub async fn refresh_access_token(&mut self) -> Result<OAuthTokenResponse> {
        info!("Refreshing OAuth access token...");

        let refresh_token = self
            .config
            .refresh_token
            .as_ref()
            .ok_or_else(|| anyhow::anyhow!("No refresh token available"))?;

        let client = reqwest::Client::new();
        let params = [
            ("client_id", self.config.client_id.clone()),
            ("client_secret", self.config.client_secret.clone()),
            ("refresh_token", refresh_token.clone()),
            ("grant_type", "refresh_token".to_string()),
        ];

        let response: serde_json::Value = client
            .post("https://oauth2.googleapis.com/token")
            .form(&params)
            .send()
            .await
            .context("Failed to refresh token")?
            .json()
            .await
            .context("Failed to parse refresh response")?;

        let access_token = response["access_token"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("No access token in refresh response"))?
            .to_string();

        let new_refresh_token = response["refresh_token"].as_str().map(|s| s.to_string());
        let expires_in = response["expires_in"].as_u64().unwrap_or(3600);

        // Update config
        self.config.access_token = Some(access_token.clone());
        self.config.refresh_token = new_refresh_token.or_else(|| Some(refresh_token.clone()));

        let now = Utc::now();
        self.config.token_expiry = Some(now + Duration::seconds(expires_in as i64));

        // Save updated configuration
        self.save_config()?;

        let token_response = OAuthTokenResponse {
            access_token,
            refresh_token: self.config.refresh_token.clone(),
            expires_in,
            token_type: "Bearer".to_string(),
            scopes: self.config.scopes.clone(),
        };

        info!("Access token refreshed successfully");
        Ok(token_response)
    }

    /// Check if token is expired or will expire soon
    #[allow(dead_code)]
    pub fn is_token_expired(&self) -> bool {
        if let Some(expiry) = self.config.token_expiry {
            let now = Utc::now();
            let expiry_buffer = expiry - Duration::minutes(5); // 5-minute buffer
            now >= expiry_buffer
        } else {
            // If we don't have expiry info, assume token might be expired
            true
        }
    }

    /// Generate authorization URL for manual token exchange
    pub fn generate_auth_url(&self) -> Result<String> {
        let mut url = url::Url::parse("https://accounts.google.com/o/oauth2/v2/auth")
            .context("Failed to parse auth URL")?;

        url.query_pairs_mut()
            .append_pair("client_id", &self.config.client_id)
            .append_pair("redirect_uri", "urn:ietf:wg:oauth:2.0:oob")
            .append_pair("response_type", "code")
            .append_pair("scope", &self.config.scopes.join(" "))
            .append_pair("access_type", "offline")
            .append_pair("prompt", "consent");

        Ok(url.to_string())
    }

    /// Exchange authorization code for tokens
    pub async fn exchange_code_for_tokens(
        &mut self,
        auth_code: &str,
    ) -> Result<OAuthTokenResponse> {
        info!("Exchanging authorization code for tokens...");

        let client = reqwest::Client::new();
        let params = [
            ("client_id", self.config.client_id.clone()),
            ("client_secret", self.config.client_secret.clone()),
            ("code", auth_code.to_string()),
            ("grant_type", "authorization_code".to_string()),
            ("redirect_uri", "urn:ietf:wg:oauth:2.0:oob".to_string()),
        ];

        let response: serde_json::Value = client
            .post("https://oauth2.googleapis.com/token")
            .form(&params)
            .send()
            .await
            .context("Failed to exchange authorization code")?
            .json()
            .await
            .context("Failed to parse token response")?;

        let access_token = response["access_token"]
            .as_str()
            .ok_or_else(|| anyhow::anyhow!("No access token in response"))?
            .to_string();

        let refresh_token = response["refresh_token"].as_str().map(|s| s.to_string());
        let expires_in = response["expires_in"].as_u64().unwrap_or(3600);

        // Update config
        self.config.access_token = Some(access_token.clone());
        self.config.refresh_token = refresh_token.clone();

        let now = Utc::now();
        self.config.token_expiry = Some(now + Duration::seconds(expires_in as i64));

        // Save updated configuration
        self.save_config()?;

        let token_response = OAuthTokenResponse {
            access_token,
            refresh_token,
            expires_in,
            token_type: "Bearer".to_string(),
            scopes: self.config.scopes.clone(),
        };

        info!("Token exchange completed successfully");
        Ok(token_response)
    }

    /// Get current OAuth configuration
    #[allow(dead_code)]
    pub fn config(&self) -> &OAuthConfig {
        &self.config
    }

    /// Check if client is authenticated
    #[allow(dead_code)]
    pub fn is_authenticated(&self) -> bool {
        self.config.access_token.is_some() || self.config.refresh_token.is_some()
    }

    /// Revoke authentication
    #[allow(dead_code)]
    pub fn revoke(&mut self) {
        info!("Revoking OAuth authentication...");
        self.config.access_token = None;
        self.config.refresh_token = None;
        self.config.token_expiry = None;

        // Remove auth files
        let _ = fs::remove_file(&self.auth_file_path);

        info!("OAuth authentication revoked");
    }

    /// Validate configuration
    #[allow(dead_code)]
    pub fn validate_config(&self) -> Result<()> {
        if self.config.client_id.is_empty() {
            return Err(anyhow::anyhow!("Client ID is required"));
        }

        if self.config.client_secret.is_empty() {
            return Err(anyhow::anyhow!("Client secret is required"));
        }

        if self.config.scopes.is_empty() {
            return Err(anyhow::anyhow!("At least one scope is required"));
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_oauth_config_default() {
        let config = OAuthConfig::default();
        assert!(!config.scopes.is_empty());
        assert!(
            config
                .scopes
                .contains(&"https://www.googleapis.com/auth/drive.file".to_string())
        );
    }

    #[test]
    fn test_oauth_client_creation() {
        let client = OAuthClient::new(
            "test_client_id".to_string(),
            "test_client_secret".to_string(),
            Some("test_refresh_token".to_string()),
        );

        assert_eq!(client.config.client_id, "test_client_id");
        assert_eq!(client.config.client_secret, "test_client_secret");
        assert_eq!(
            client.config.refresh_token,
            Some("test_refresh_token".to_string())
        );
    }

    #[test]
    fn test_auth_url_generation() {
        let client = OAuthClient::new(
            "test_client_id".to_string(),
            "test_client_secret".to_string(),
            None,
        );

        let url = client.generate_auth_url().unwrap();
        assert!(url.contains("accounts.google.com"));
        assert!(url.contains("test_client_id"));
        assert!(url.contains("drive.file"));
    }

    #[test]
    fn test_config_validation() {
        let valid_client = OAuthClient::new(
            "test_client_id".to_string(),
            "test_client_secret".to_string(),
            None,
        );
        assert!(valid_client.validate_config().is_ok());

        let invalid_client =
            OAuthClient::new("".to_string(), "test_client_secret".to_string(), None);
        assert!(invalid_client.validate_config().is_err());
    }

    #[tokio::test]
    async fn test_config_save_load() -> Result<()> {
        let temp_dir = TempDir::new()?;
        let auth_path = temp_dir.path().join("test_auth.json");

        let mut client = OAuthClient::new(
            "test_client_id".to_string(),
            "test_client_secret".to_string(),
            Some("test_refresh_token".to_string()),
        );

        // Override the auth file path for testing
        client.auth_file_path = auth_path.clone();

        // Save config
        client.save_config()?;

        // Load config from the temporary file path
        let loaded_config = OAuthClient::load_config_from_path(&auth_path)?.unwrap();
        assert_eq!(loaded_config.client_id, "test_client_id");
        assert_eq!(loaded_config.client_secret, "test_client_secret");
        assert_eq!(
            loaded_config.refresh_token,
            Some("test_refresh_token".to_string())
        );

        // Verify scopes field is present
        assert!(!loaded_config.scopes.is_empty());
        assert!(
            loaded_config
                .scopes
                .contains(&"https://www.googleapis.com/auth/drive.file".to_string())
        );

        Ok(())
    }
}
